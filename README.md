# Implementatations of Key Algorithms

Efficient algorithms are important when processing large data sets.
Simple implementations where computation is proportional to the square of the number of elements n (O(n^2)) 
become completely impractical for large data sets.

## Organized by Language
  - [Go](/go)
  - [Python](/python)
  - [Scala](/scala)
  
## Organized by Categories
| Type | Description | Source |  Language |
| --- | --- | --- | --- |
| Stack | Valid Parenthesis | [LC20](https://leetcode.com/problems/valid-parentheses/) | [Go](go/20_Valid_Parentheses.go)
| Linked List | MergeTwoSortedLists | [LC21](https://leetcode.com/problems/merge-two-sorted-lists/) | [Go](go/21_Merge_Sorted_Lists.go)
| | Merge k Sorted List | [LC23]]() | [Go](go/23_Merge_Sorted_Lists.go)
| | Trapping Rain Water | [LC42]() | [Go](go/42_Trapping_Water.go)
| | Maximum Subarray | [LC53]() | [Go](go/53_Maximum_Subarray.go)
| | Climbing Stairs | [LC70]() | [Go](go/70_Climbing_Stairs.go)
| | Binary Tree Inorder Traversal | [LC94]() | [Go](go/94_Binary_Tree_Inorder.go)
| | Binary Tree Level Order Traversal | [LC102]() | [Go](go/102_Tree_Level_Traversal.go)
| | Maximum Depth of Binary Tree | [LC104]() | [Go](104_Maximum_Tree_Depth.go)
| | Convert Sorted Array to Binary Search Tree | [LC108]() | [Go](108_Sorted_Array_to_Tree.go)
| | Balanced Binary Tree | [LC110]() | [Python](python/110_Balanced_Binary.py)
| | Single Number | [LC136]() | [Go](136_Single_Number.go)
| | Majority Element | [LC169]() | [Scala](169_majority_element.scala)
| | Reverse Linked List | [LC206]() | [Python](169_majority_element.scala)
| | Valid Anagram | [LC242]() | [Scala](242_Valid_Anagram.scala)
| | Fibonacci Number | [LC509]() | [Go](509_Fibonacci.go)
| Sorting | Sort Array | [LC912]() | [Python](python/912_sortarray.py)
| Concurrency | [Print In Order | [LC1114]() | [Python](python/1114_PrintInOrder.py)
| Concurrency | [Foo Bar Alternate | [LC1115]() | [Python](python/1115_FooBarAlternate.py)






